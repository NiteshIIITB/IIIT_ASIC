# ASIC_Design_ProjectWork
This repository highlights the work done by Nitesh Sharma pretaining to ASIC Design course.
<br>
Quick links:
<br>
[Tools Installation](#day0)
<details>
  <summary> <strong>Day_0</strong></summary>
	<a name="day0"></a>
   <details>
     <summary>iverilog</summary>
     Commands used for iverilog installation:
     
         
```
sudo apt-get update
sudo apt-get install iverilog
```
iverilog Installation
<img src="https://user-images.githubusercontent.com/140998787/257133371-5ee81e29-7172-4958-8619-d11be643f8be.png">
    
Checking for installation:
<img src="https://user-images.githubusercontent.com/140998787/257133385-23e46cdd-5286-4ac5-bfa6-ed7c014c27e5.png">
   </details>
  <details>
    <summary>gtkwave</summary>
Command used for gtkwave installation
    
```
        sudo apt-get install gtkwave
```
    
    
gtkwave installation:

<img src ="https://user-images.githubusercontent.com/140998787/257133351-15fdb0a8-0544-42ec-9728-ccc504e13f57.png">

Checking for Installation<br>
<img src =https://user-images.githubusercontent.com/140998787/257133362-8a86c9a3-9e0b-4685-882f-7aa89ffb799a.png>
    
  </details>
  <details>
    <summary>Yosys</summary>
    Commands for Yosys Installation:
		
```
sudo apt-get update
sudo apt-get install yosys
```

Yosys Installation:
<br>
    <img src="https://user-images.githubusercontent.com/140998787/257133314-abdfaa0a-5801-477e-8d73-dc2c873db915.png">
    <br>
Checking Installation of Yosys
    <br>
    <img src="https://user-images.githubusercontent.com/140998787/257133324-7888d6c3-e880-4da1-b751-961ec80847b8.png">
  </details>
</details>



<details>
	<summary><strong>Day 1</strong></summary>
	<h3>Overview</h3>
        <p>Today I performed Logic synthesis of a simple 2X1 MUX based on <a>sky130_fd_sc_hd__tt_025C_1v80</a> library  as my LAB 1 work. Tools used in this process included : 
	<ul>
		<li>Iverilog</li>
		<li>GTKwave</li>
		<li>Yosys</li>
	</ul>
<hr>
	<h4>Step 0</h4> Accesing necessary resources from <a href ="https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop">github.</a><br>
	<img src = "https://user-images.githubusercontent.com/140998787/259470853-fb49dc3d-fd55-4d65-b31c-8b8fd15e8b4d.png">
  <h4>Step 1</h4> Below is the verilog code for a 2x1 MUX:<br>
	
```
   module good_mux (input i0 , input i1 , input sel , output reg y);
   always @ (*)
   begin
	if(sel)
		y <= i1;
	else 
		y <= i0;
   end
   endmodule
   
```
<br>
Testbench

```
`timescale 1ns / 1ps
module tb_good_mux;
	// Inputs
	reg i0,i1,sel;
	// Outputs
	wire y;

        // Instantiate the Unit Under Test (UUT)
	good_mux uut (
		.sel(sel),
		.i0(i0),
		.i1(i1),
		.y(y)
	);

	initial begin
	$dumpfile("tb_good_mux.vcd");
	$dumpvars(0,tb_good_mux);
	// Initialize Inputs
	sel = 0;
	i0 = 0;
	i1 = 0;
	#300 $finish;
	end

always #75 sel = ~sel;
always #10 i0 = ~i0;
always #55 i1 = ~i1;
endmodule
```
<br>
Command used to simulate code and corresponding Testbench:

```
iverilog good_mux.v tb_good_mux.v

```
<br>
Command for viewing output waveforms:

```
gtkwave
```
<br>
Image for execution of above commands
<img src = "https://user-images.githubusercontent.com/140998787/259437514-7856401e-6790-4f8a-95c0-bec59d68a400.png">
<br>

<img src ="https://user-images.githubusercontent.com/140998787/259467729-00235466-2269-4be8-a22e-83b48714f58f.png">
<br>
<h4>Step 2:</h4> <br>
Once it is verified that code produces the same output as expected . Now we add libraries related to technology node and generate schematic and netlist using yosys.
Following commands are used for doing so:

```
yosys
```

```
read_liberty -lib file_address
```

```
read_verilog Verilog_Filename.v
```

```
synth -top Design_name
```

```
abc -liberty library_location
```

<br>
<img src = "https://user-images.githubusercontent.com/140998787/259470836-dd472df9-c279-445a-bf5f-d429a8363118.png">
<img src =" https://user-images.githubusercontent.com/140998787/259481064-7ad5f69c-1a2a-4e71-b9db-2006e45d6ae4.png">
<br>
Generated Schematic using Technology Cells: <br>
<img src="https://user-images.githubusercontent.com/140998787/259481001-a89d0297-30c1-4dc2-bb4e-b8231d8f99af.png">


<br>
<img src ="https://user-images.githubusercontent.com/140998787/259470856-2f8403a1-427e-4b63-98d5-b24ad5da08c1.png">
<br><br>
Generated Netlist
<br><br>

```
/* Generated by Yosys 0.23 (git sha1 7ce5011c24b) */

module good_mux(i0, i1, sel, y);
  wire _0_;
  wire _1_;
  wire _2_;
  wire _3_;
  input i0;
  wire i0;
  input i1;
  wire i1;
  input sel;
  wire sel;
  output y;
  wire y;
  sky130_fd_sc_hd__mux2_1 _4_ (
    .A0(_0_),
    .A1(_1_),
    .S(_2_),
    .X(_3_)
  );
  assign _0_ = i0;
  assign _1_ = i1;
  assign _2_ = sel;
  assign y = _3_;
endmodule
```



</p>
	
</details>
<details>
	<summary><strong>Day 3</strong></summary>
	<h2>Theory</h2>
	<h3>Overview</h3>
	<p>This section highlights various logic optimisations performed by the synthesis tools.The major advantage of doing optimisations is that design becomes efficient and occupies less area and consumes lesser power. </p>
	<h3>Combinational logic optimisations</h3>
	<p>Common ways of doing combinational logic optimisations:
	 <ul>
		 <li><b>Constant Propogation :</b>Constant propagation is a specific technique used in logic optimization to simplify combinational logic circuits by replacing variables with                            their constant values wherever possible. This optimization helps reduce the complexity of the circuit and can lead to improvements in both performance and area          utilization.</li>
		 <li><b>Boolean Logic Optimisation :</b>
		 <ul>
			 <li>Karnaugh Maps (K-Maps): A graphical method used to identify and group minterms or maxterms in a truth table, leading to simplified Boolean expressions.</li>
			 <li>Quine-McCluskey Method: An algorithmic approach to find the minimal sum-of-products (or product-of-sums) expressions for a Boolean function. </li>
		 </ul>There are various other ways of Boolean logic Optimisations.</li>
	 </ul><br>Demonstrations of these optimisations are included in the following lab work.</p>
	<h3>Sequential Logic Optimisations</h3>
	<p>
		<ul>
			<li><b>Basic</b>
			<ul><li>Sequential Constant Propogation: Similar to combinational logic optimization, the goal is to identify signals that are guaranteed to be constant at specific points                                  in time and then propagate these constants through the sequential elements.</li></ul>
			Demonstrations of these are included in the following</li>
                       <li><b>Advanced</b>
		           <ul>
			    <li>State Optimisation : State optimization minimizes the number of states in a finite state machine by identifying and collapsing equivalent or unreachable states,                                      reducing complexity and improving efficiency.</li> 
			      <li>Sequential Logic Cloning</li> 
			       <li>Retiming : It refers to adjusting delays of intermediate combinational circuits to enhance the operating speed of the digital circuit.</li>
		             </ul>
		       </li>	
		</ul>
	</p>
	<h2>Demonstrations</h2>
	<h3>Combinational logic optimisation</h3>

 ```
module opt_check (input a , input b , output y);
	assign y = a?b:0;
endmodule
```

<br>
<b>Conventional Implementation:</b>
   <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  <br>
  <b>Synthesis Tool Output:</b>
   <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  <br>
  
    
<p>
	<b>Equivalence of both</b><br>
	
```
         From Conventional  Circuit:
	 Y = a.b + a`.0
         Y = a.b
	 Both circuits are equivalent
	
```

</p>
<p>
	<h4>Steps Involved</h4>
	 <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
<br>
 <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  <br>
   <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  <br>
   <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  
</p>
<br>

<b>Design 2</b><br>
```
module opt_check2 (input a , input b , output y);
	assign y = a?1:b;
endmodule
```
<br>
<b>Conventional Implementation:</b>
   <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  <br>
  <b>Synthesis Tool Output:</b>
   <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  <br>
  
    
<p>
	<b>Equivalence of both</b><br>
	
```
         From Conventional  Circuit:
	 Y = a.1 + a`.b
         Y = a + a`.b   
         Y = a + b  (by distributive law)
	 Both circuits are equivalent(Inverted Nand is equivalent to OR gate)
	
```

</p>
<p>
	<h4>Steps Involved</h4>
	 <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
<br>
 <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  <br>
   <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  <br>
   <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  
</p>

<br>

<b>Design 3</b><br>
```

module opt_check3 (input a , input b, input c , output y);
	assign y = a?(c?b:0):0;
endmodule
```
<br>
<b>Conventional Implementation:</b>
   <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  <br>
  <b>Synthesis Tool Output:</b>
   <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  <br>
  
    
<p>
	<b>Equivalence of both</b><br>
	
```
         From Conventional  Circuit:
	 Y = a.(c.b + c`.0) + a`.0
         Y = a(b.c) + 0  
         Y = a.b.c 
	 Both circuits are equivalent
	
```

</p>
<p>
	<h4>Steps Involved</h4>
	 <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
<br>
 <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  <br>
   <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  <br>
   <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  
</p>

<br>

<b>Design 4</b><br>
```

module opt_check4 (input a , input b , input c , output y);
 assign y = a?(b?(a & c ):c):(!c);
 endmodule
```
<br>
<b>Conventional Implementation:</b>
   <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  <br>
  <b>Synthesis Tool Output:</b>
   <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  <br>
  
    
<p>
	<b>Equivalence of both</b><br>
	
```
         From Conventional  Circuit:
	 Y = a.(b(a.c)+ b`c) + a`.c`
         Y = a(b.c.a + b`c) + a`.c`
         Y = ac(a+b`) + a`.c`
         Y = ac +
         Y = a.b.c 
	 Both circuits are equivalent
	
```

</p>
<p>
	<h4>Steps Involved</h4>
	 <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
<br>
 <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  <br>
   <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  <br>
   <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  
</p>


<br>

<b>Design 5</b><br>
```

module sub_module1(input a , input b , output y);
 assign y = a & b;
endmodule


module sub_module2(input a , input b , output y);
 assign y = a^b;
endmodule


module multiple_module_opt(input a , input b , input c , input d , output y);
wire n1,n2,n3;

sub_module1 U1 (.a(a) , .b(1'b1) , .y(n1));
sub_module2 U2 (.a(n1), .b(1'b0) , .y(n2));
sub_module2 U3 (.a(b), .b(d) , .y(n3));

assign y = c | (b & n1); 


endmodule
```
<br>
<b>Conventional Implementation:</b>
   <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  <br>
  <b>Synthesis Tool Output:</b>
   <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  <br>
  
    
<p>
	<b>Equivalence of both</b><br>
	
```
         From Conventional  Circuit:
	 Y = a.(b(a.c)+ b`c) + a`.c`
         Y = a(b.c.a + b`c) + a`.c`
         Y = ac(a+b`) + a`.c`
         Y = ac +
         Y = a.b.c 
	 Both circuits are equivalent
	
```

</p>
<p>
	<h4>Steps Involved</h4>
	 <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
<br>
 <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  <br>
   <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  <br>
   <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  
</p>

<br>

<b>Design 6</b><br>
```


module sub_module(input a , input b , output y);
 assign y = a & b;
endmodule



module multiple_module_opt2(input a , input b , input c , input d , output y);
wire n1,n2,n3;

sub_module U1 (.a(a) , .b(1'b0) , .y(n1));
sub_module U2 (.a(b), .b(c) , .y(n2));
sub_module U3 (.a(n2), .b(d) , .y(n3));
sub_module U4 (.a(n3), .b(n1) , .y(y));


endmodule
```
<br>
<b>Conventional Implementation:</b>
   <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  <br>
  <b>Synthesis Tool Output:</b>
   <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  <br>
  
    
<p>
	<b>Equivalence of both</b><br>
	
```
         From Conventional  Circuit:
	 Y = a.(b(a.c)+ b`c) + a`.c`
         Y = a(b.c.a + b`c) + a`.c`
         Y = ac(a+b`) + a`.c`
         Y = ac +
         Y = a.b.c 
	 Both circuits are equivalent
	
```

</p>
<p>
	<h4>Steps Involved</h4>
	 <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
<br>
 <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  <br>
   <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  <br>
   <div align="center">
    <img src="path-to-your-image.jpg">
  </div>
  
</p>






</details>

<h2>References</h2>
<ul>
	<li><a href ="https://github.com/kunalg123/">Kunal Ghosh Github(Mentor)</a></li>
	
</ul>
